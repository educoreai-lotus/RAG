/**
 * Vector Search Service
 * Handles vector similarity search using pgvector
 */

import { getPrismaClient } from '../config/database.config.js';
import { logger } from '../utils/logger.util.js';
import { Prisma } from '@prisma/client';

/**
 * Search for similar vectors using cosine similarity
 * @param {number[]} queryEmbedding - Query embedding vector (1536 dimensions)
 * @param {string} tenantId - Tenant identifier
 * @param {Object} options - Search options
 * @param {number} options.limit - Maximum number of results (default: 5)
 * @param {number} options.threshold - Minimum similarity threshold (default: 0.7)
 * @param {string} options.contentType - Filter by content type (optional)
 * @param {string} options.contentId - Filter by content ID (optional)
 * @param {string} options.microserviceId - Filter by microservice ID (optional)
 * @param {string[]} options.microserviceIds - Filter by multiple microservice IDs (optional)
 * @returns {Promise<Array>} Array of similar vector embeddings
 */
export async function searchSimilarVectors(
  queryEmbedding,
  tenantId,
  options = {}
) {
  const { 
    limit = 5, 
    threshold = 0.7, 
    contentType, 
    contentId,
    microserviceId,
    microserviceIds 
  } = options;

  try {
    const prisma = await getPrismaClient();

    // Build the query using raw SQL for pgvector similarity search
    // pgvector uses cosine distance: 1 - cosine_similarity
    // We want results where similarity > threshold
    
    // Convert embedding array to PostgreSQL vector format
    const embeddingStr = `[${queryEmbedding.join(',')}]`;

    // Build WHERE clause using Prisma.sql for safe parameterization
    let whereConditions = [Prisma.sql`tenant_id = ${tenantId}`];

    if (contentType) {
      whereConditions.push(Prisma.sql`content_type = ${contentType}`);
    }

    if (contentId) {
      whereConditions.push(Prisma.sql`content_id = ${contentId}`);
    }

    // Filter by single microservice
    if (microserviceId) {
      whereConditions.push(Prisma.sql`microservice_id = ${microserviceId}`);
    }

    // Filter by multiple microservices
    if (microserviceIds && microserviceIds.length > 0) {
      whereConditions.push(Prisma.sql`microservice_id IN (${Prisma.join(microserviceIds)})`);
    }

    // Build the complete query using Prisma.sql template tag
    // For vector type, we need to use Prisma.raw since Prisma.sql doesn't support vector casting directly
    // The embedding string is safe as it's generated by OpenAI, not user input
    // Format: '[1.0,2.0,3.0]'::vector - must be a properly formatted string literal
    const embeddingVectorLiteral = Prisma.raw(`'${embeddingStr}'::vector`);
    
    const query = Prisma.sql`
      SELECT 
        id,
        tenant_id,
        microservice_id,
        content_id,
        content_type,
        content_text,
        chunk_index,
        metadata,
        created_at,
        1 - (embedding <=> ${embeddingVectorLiteral}) as similarity
      FROM vector_embeddings
      WHERE ${Prisma.join(whereConditions, Prisma.sql` AND `)}
        AND (1 - (embedding <=> ${embeddingVectorLiteral})) >= ${threshold}
      ORDER BY embedding <=> ${embeddingVectorLiteral}
      LIMIT ${limit}
    `;

    const results = await prisma.$queryRaw(query);

    logger.info('Vector search completed', {
      tenantId,
      resultsCount: results.length,
      threshold,
      limit,
      queryEmbeddingLength: queryEmbedding?.length || 0,
      hasResults: results.length > 0,
      topSimilarity: results.length > 0 ? parseFloat(results[0].similarity) : null,
    });
    
    // Log first result details for debugging
    if (results.length > 0) {
      logger.debug('Vector search top result', {
        contentId: results[0].content_id,
        contentType: results[0].content_type,
        similarity: parseFloat(results[0].similarity),
        contentTextPreview: results[0].content_text?.substring(0, 100),
      });
    } else {
      // If no results, check if there's any data in the table
      const totalCount = await prisma.$queryRaw(
        Prisma.sql`SELECT COUNT(*)::int as count FROM vector_embeddings WHERE tenant_id = ${tenantId}`
      );
      
      // Also check all tenants to see if data exists with different tenant_id
      const allTenantsCount = await prisma.$queryRaw(
        Prisma.sql`SELECT tenant_id, COUNT(*)::int as count FROM vector_embeddings GROUP BY tenant_id`
      );
      
      // Check if "Eden Levi" exists with any tenant_id
      const edenLeviCheck = await prisma.$queryRaw(
        Prisma.sql`SELECT tenant_id, content_id, content_text FROM vector_embeddings WHERE content_id = ${'user:manager-001'} LIMIT 5`
      );
      
      // Also try a query without threshold to see what similarities we get
      const embeddingVectorTest = Prisma.raw(`'${embeddingStr}'::vector`);
      const testQuery = Prisma.sql`
        SELECT 
          content_id,
          content_type,
          1 - (embedding <=> ${embeddingVectorTest}) as similarity
        FROM vector_embeddings
        WHERE tenant_id = ${tenantId}
        ORDER BY embedding <=> ${embeddingVectorTest}
        LIMIT 10
      `;
      const topResults = await prisma.$queryRaw(testQuery).catch(() => []);
      
      logger.warn('No vector search results found', {
        tenantId,
        threshold,
        totalRecordsForThisTenant: totalCount[0]?.count || 0,
        allTenantsData: allTenantsCount,
        edenLeviExists: edenLeviCheck.length > 0,
        edenLeviTenantIds: edenLeviCheck.map(r => r.tenant_id),
        topSimilaritiesWithoutThreshold: topResults.slice(0, 5).map(r => ({
          contentId: r.content_id,
          contentType: r.content_type,
          similarity: parseFloat(r.similarity),
        })),
        queryEmbeddingDimensions: queryEmbedding.length,
        queryEmbeddingPreview: queryEmbedding.slice(0, 5),
      });
    }

    return results.map((row) => ({
      id: row.id,
      tenantId: row.tenant_id,
      microserviceId: row.microservice_id,
      contentId: row.content_id,
      contentType: row.content_type,
      contentText: row.content_text,
      chunkIndex: row.chunk_index,
      metadata: row.metadata || {},
      similarity: parseFloat(row.similarity),
      createdAt: row.created_at,
    }));
  } catch (error) {
    logger.error('Vector search error', {
      error: error.message,
      tenantId,
      stack: error.stack,
    });
    throw new Error(`Vector search failed: ${error.message}`);
  }
}

/**
 * Store vector embedding in database
 * @param {Object} embeddingData - Embedding data
 * @param {string} embeddingData.tenantId - Tenant identifier
 * @param {string} embeddingData.contentId - Content identifier
 * @param {string} embeddingData.contentType - Content type
 * @param {number[]} embeddingData.embedding - Embedding vector (1536 dimensions)
 * @param {string} embeddingData.contentText - Original content text
 * @param {number} embeddingData.chunkIndex - Chunk index (default: 0)
 * @param {Object} embeddingData.metadata - Additional metadata
 * @returns {Promise<Object>} Created embedding record
 */
export async function storeVectorEmbedding(embeddingData) {
  const {
    tenantId,
    contentId,
    contentType,
    embedding,
    contentText,
    chunkIndex = 0,
    metadata = {},
  } = embeddingData;

  try {
    const prisma = await getPrismaClient();

    // Use raw SQL to insert vector embedding
    // Prisma doesn't support vector type directly, so we use raw SQL
    const embeddingArray = `[${embedding.join(',')}]`;

    const query = `
      INSERT INTO vector_embeddings (
        id,
        tenant_id,
        content_id,
        content_type,
        embedding,
        content_text,
        chunk_index,
        metadata,
        created_at,
        updated_at
      ) VALUES (
        gen_random_uuid()::text,
        $1,
        $2,
        $3,
        $4::vector,
        $5,
        $6,
        $7::jsonb,
        NOW(),
        NOW()
      )
      RETURNING *
    `;

    const result = await prisma.$queryRawUnsafe(
      query,
      tenantId,
      contentId,
      contentType,
      embeddingArray,
      contentText,
      chunkIndex,
      JSON.stringify(metadata)
    );

    logger.info('Vector embedding stored', {
      tenantId,
      contentId,
      contentType,
      chunkIndex,
    });

    return {
      id: result[0].id,
      tenantId: result[0].tenant_id,
      contentId: result[0].content_id,
      contentType: result[0].content_type,
      chunkIndex: result[0].chunk_index,
      metadata: result[0].metadata || {},
      createdAt: result[0].created_at,
    };
  } catch (error) {
    logger.error('Store vector embedding error', {
      error: error.message,
      tenantId,
      contentId,
      stack: error.stack,
    });
    throw new Error(`Store vector embedding failed: ${error.message}`);
  }
}

/**
 * Delete vector embeddings by content ID
 * @param {string} tenantId - Tenant identifier
 * @param {string} contentId - Content identifier
 * @returns {Promise<number>} Number of deleted embeddings
 */
export async function deleteVectorEmbeddings(tenantId, contentId) {
  try {
    const prisma = await getPrismaClient();

    const result = await prisma.$executeRawUnsafe(
      `
      DELETE FROM vector_embeddings
      WHERE tenant_id = $1 AND content_id = $2
    `,
      tenantId,
      contentId
    );

    logger.info('Vector embeddings deleted', {
      tenantId,
      contentId,
      deletedCount: result,
    });

    return result;
  } catch (error) {
    logger.error('Delete vector embeddings error', {
      error: error.message,
      tenantId,
      contentId,
      stack: error.stack,
    });
    throw new Error(`Delete vector embeddings failed: ${error.message}`);
  }
}
